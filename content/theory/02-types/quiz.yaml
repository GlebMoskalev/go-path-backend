questions:
  # 01-numbers
  - question: "Какой тип является алиасом для uint8?"
    options:
      - "char"
      - "byte"
      - "rune"
      - "int8"
    answer: 1
    explanation: "byte — это алиас для uint8. Используется для работы с байтами данных."

  - question: "Что произойдёт при приведении int64(1000) к int8?"
    options:
      - "Ошибка компиляции"
      - "Значение обрежется с возможной потерей данных"
      - "Автоматическое расширение int8"
      - "Паника во время выполнения"
    answer: 1
    explanation: "Go выполняет явное приведение, но при сужении типа возможна потеря данных. int8 вмещает только -128..127, поэтому 1000 переполнится."

  - question: "Что вернёт выражение 17 / 5 в Go (оба операнда int)?"
    options:
      - "3.4"
      - "3"
      - "4"
      - "ошибку компиляции"
    answer: 1
    explanation: "При целочисленном делении дробная часть отбрасывается. 17 / 5 = 3."

  - question: "Какой тип с плавающей точкой используется по умолчанию для литералов?"
    options:
      - "float32"
      - "float64"
      - "decimal"
      - "double"
    answer: 1
    explanation: "В Go литералы с плавающей точкой по умолчанию имеют тип float64 — он точнее (∼15 знаков)."

  # 02-strings
  - question: "Что возвращает len(\"Привет\") в Go?"
    options:
      - "6"
      - "12"
      - "7"
      - "ошибку компиляции"
    answer: 1
    explanation: "len() возвращает количество байтов, а не символов. Кириллические символы в UTF-8 занимают по 2 байта, поэтому 6 × 2 = 12."

  - question: "Какой тип является алиасом для int32 и представляет один символ Unicode?"
    options:
      - "byte"
      - "char"
      - "rune"
      - "symbol"
    answer: 2
    explanation: "rune — алиас для int32, представляет один символ Unicode (code point)."

  - question: "Какой пакет используется для эффективной конкатенации множества строк?"
    options:
      - "fmt"
      - "strings.Builder"
      - "bytes"
      - "io"
    answer: 1
    explanation: "strings.Builder — рекомендованный способ собирать строку по частям. Он минимизирует аллокации памяти."

  - question: "Что произойдёт при попытке изменить символ строки: s[0] = 'H'?"
    options:
      - "Символ изменится"
      - "Ошибка компиляции — строки неизменяемы"
      - "Паника во время выполнения"
      - "Изменится только локальная копия"
    answer: 1
    explanation: "Строки в Go неизменяемы (immutable). Для модификации нужно сконвертировать в []byte или []rune, изменить и сконвертировать обратно."

  # 03-slices
  - question: "Чем слайс отличается от массива в Go?"
    options:
      - "Слайс хранит только указатели"
      - "Слайс имеет динамическую длину, массив — фиксированную"
      - "Массив быстрее слайса"
      - "Слайс не может содержать структуры"
    answer: 1
    explanation: "Массив имеет фиксированную длину (часть типа), а слайс — динамическая обёртка над массивом с изменяемой длиной."

  - question: "Что делает функция append?"
    options:
      - "Изменяет слайс на месте"
      - "Возвращает новый слайс с добавленными элементами"
      - "Добавляет элемент в начало слайса"
      - "Объединяет два массива"
    answer: 1
    explanation: "append возвращает новый слайс. Результат нужно присваивать: s = append(s, elem). Оригинальный слайс может остаться без изменений."

  - question: "Что выведет код: s := []int{1,2,3}; t := s[:2]; t[0] = 99; fmt.Println(s[0])?"
    options:
      - "1"
      - "99"
      - "0"
      - "ошибку компиляции"
    answer: 1
    explanation: "Срез (slicing) ссылается на тот же базовый массив. Изменение t[0] также изменит s[0]."

  - question: "Как создать слайс длиной 0 с ёмкостью 10?"
    options:
      - "make([]int, 10)"
      - "make([]int, 0, 10)"
      - "new([]int, 10)"
      - "[]int{cap: 10}"
    answer: 1
    explanation: "make([]int, 0, 10) создаёт слайс с длиной 0 и ёмкостью 10. Первый аргумент — тип, второй — длина, третий — ёмкость."

  # 04-maps
  - question: "Что произойдёт при чтении несуществующего ключа из map?"
    options:
      - "Паника (panic)"
      - "Ошибка компиляции"
      - "Вернётся нулевое значение типа"
      - "Вернётся nil"
    answer: 2
    explanation: "При обращении к несуществующему ключу map возвращает нулевое значение типа (0 для int, \"\" для string и т.д.)."

  - question: "Как проверить наличие ключа в map?"
    options:
      - "map.has(key)"
      - "key in map"
      - "value, ok := map[key]"
      - "map.contains(key)"
    answer: 2
    explanation: "Идиоматичный способ — value, ok := m[key]. Если ok == true, ключ существует."

  - question: "Что произойдёт при записи в nil-карту?"
    options:
      - "Карта создастся автоматически"
      - "Вернётся ошибка"
      - "Паника: assignment to entry in nil map"
      - "Значение будет проигнорировано"
    answer: 2
    explanation: "Запись в nil-карту вызывает панику. Карту нужно инициализировать через make() или литерал перед записью."

  - question: "Гарантирован ли порядок перебора map через range?"
    options:
      - "Да, по порядку вставки"
      - "Да, по алфавиту ключей"
      - "Нет, порядок не гарантирован"
      - "Да, по хешу ключа"
    answer: 2
    explanation: "Порядок перебора map в Go не гарантирован. При каждом запуске он может быть разным."

  # 05-structs
  - question: "Как рекомендуется создавать экземпляр структуры?"
    options:
      - "Указывая поля по порядку без имён"
      - "Используя именованные поля"
      - "Через функцию new()"
      - "Через конструктор класса"
    answer: 1
    explanation: "Рекомендуется использовать именованные поля: User{Name: \"Боб\", Age: 30}. Это делает код устойчивым к изменению порядка полей."

  - question: "Что такое встраивание (embedding) структур?"
    options:
      - "Наследование классов"
      - "Включение структуры без имени поля для «продвижения» её полей и методов"
      - "Создание копии структуры"
      - "Импорт структуры из другого пакета"
    answer: 1
    explanation: "Встраивание — включение типа без имени поля. Поля и методы встроенного типа «продвигаются» и доступны напрямую."

  - question: "Для чего используются теги (tags) структур?"
    options:
      - "Для комментирования кода"
      - "Для сериализации, валидации и ORM"
      - "Для ограничения доступа к полям"
      - "Для автоматической генерации SQL"
    answer: 1
    explanation: "Теги (например, `json:\"name\"`) используются библиотеками для сериализации (JSON, XML), валидации, ORM и других целей."

  - question: "Можно ли сравнивать структуры через == если они содержат слайс?"
    options:
      - "Да, всегда"
      - "Нет, нужно использовать reflect.DeepEqual"
      - "Да, но только если слайсы одной длины"
      - "Нет, слайсы нельзя помещать в структуры"
    answer: 1
    explanation: "Структуры со слайсами или map нельзя сравнивать через ==. Для таких случаев используется reflect.DeepEqual."
