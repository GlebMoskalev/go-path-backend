---
title: "Горутины"
description: "Легковесные потоки Go: запуск, время жизни, WaitGroup"
order: 1
---

# Горутины

Горутина — легковесный поток исполнения, управляемый рантаймом Go. Тысячи горутин могут работать одновременно, потребляя минимум памяти (~2 КБ стека).

## Запуск горутины

```go
go someFunction()
```

Ключевое слово `go` запускает функцию в отдельной горутине.

```go
func sayHello(name string) {
    fmt.Printf("Привет, %s!\n", name)
}

func main() {
    go sayHello("Гофер")
    go sayHello("Мир")

    time.Sleep(100 * time.Millisecond) // ждём завершения
}
```

> **Проблема:** `time.Sleep` — ненадёжный способ ожидания. Используйте `sync.WaitGroup`.

## sync.WaitGroup

```go
func main() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("горутина %d\n", id)
        }(i)
    }

    wg.Wait() // блокируется, пока счётчик не станет 0
    fmt.Println("все горутины завершились")
}
```

### Методы WaitGroup

| Метод    | Описание                          |
|----------|-----------------------------------|
| `Add(n)` | Увеличивает счётчик на n          |
| `Done()` | Уменьшает счётчик на 1            |
| `Wait()` | Блокируется, пока счётчик > 0     |

## Анонимные горутины

```go
go func() {
    fmt.Println("анонимная горутина")
}()
```

## Замыкание и горутины — ловушка!

```go
// НЕПРАВИЛЬНО — все горутины могут увидеть одно и то же значение i
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i) // гонка данных!
    }()
}

// ПРАВИЛЬНО — передаём i как аргумент
for i := 0; i < 5; i++ {
    go func(n int) {
        fmt.Println(n)
    }(i)
}
```

> Начиная с Go 1.22 переменная цикла `for` создаётся заново на каждой итерации, что решает эту проблему.

## Сколько горутин можно создать?

```go
func main() {
    for i := 0; i < 100_000; i++ {
        go func(n int) {
            time.Sleep(time.Second)
        }(i)
    }
    fmt.Println("запущено 100 000 горутин")
    time.Sleep(2 * time.Second)
}
```

Go легко справляется с сотнями тысяч горутин — каждая занимает ~2-8 КБ памяти.

## GOMAXPROCS

Количество потоков ОС, на которых выполняются горутины:

```go
import "runtime"

fmt.Println(runtime.GOMAXPROCS(0)) // текущее значение
runtime.GOMAXPROCS(4)               // установить 4
fmt.Println(runtime.NumGoroutine()) // количество горутин
```

По умолчанию равно количеству ядер процессора.

> **Совет:** горутины дешёвые, но не забывайте о завершении. Утечка горутин — частая проблема. Всегда обеспечивайте способ завершения горутины (каналы, контексты).
