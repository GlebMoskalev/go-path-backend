questions:
  # 01-goroutines
  - question: "Каким ключевым словом запускается горутина?"
    options:
      - "async"
      - "spawn"
      - "go"
      - "thread"
    answer: 2
    explanation: "Горутина запускается ключевым словом go перед вызовом функции: go someFunction()."

  - question: "Сколько примерно памяти занимает одна горутина при создании?"
    options:
      - "1 МБ"
      - "~2 КБ"
      - "64 КБ"
      - "512 байт"
    answer: 1
    explanation: "Горутина занимает около 2-8 КБ стека при создании. Это позволяет запускать сотни тысяч горутин."

  - question: "Какой метод sync.WaitGroup уменьшает счётчик на 1?"
    options:
      - "Add(-1)"
      - "Done()"
      - "Dec()"
      - "Finish()"
    answer: 1
    explanation: "wg.Done() уменьшает счётчик WaitGroup на 1. Обычно вызывается через defer wg.Done() в начале горутины."

  - question: "Какую проблему решает передача переменной цикла как аргумента горутины?"
    options:
      - "Утечку памяти"
      - "Гонку данных — все горутины могут видеть одно и то же значение"
      - "Deadlock"
      - "Переполнение стека"
    answer: 1
    explanation: "Без передачи аргументом все горутины разделяют одну переменную цикла и могут увидеть последнее значение. Передача копирует значение."

  - question: "Что определяет GOMAXPROCS?"
    options:
      - "Максимальное число горутин"
      - "Количество потоков ОС для выполнения горутин"
      - "Размер стека горутины"
      - "Таймаут ожидания горутины"
    answer: 1
    explanation: "GOMAXPROCS определяет количество потоков ОС, на которых параллельно выполняются горутины. По умолчанию — число ядер CPU."

  # 02-channels
  - question: "Какой канал блокирует отправителя, пока получатель не примет значение?"
    options:
      - "Буферизованный"
      - "Небуферизованный"
      - "Закрытый"
      - "Направленный"
    answer: 1
    explanation: "Небуферизованный канал (make(chan T)) блокирует отправителя до тех пор, пока другая горутина не прочитает значение."

  - question: "Что произойдёт при записи в закрытый канал?"
    options:
      - "Значение будет проигнорировано"
      - "Вернётся ошибка"
      - "Паника (panic)"
      - "Канал автоматически откроется"
    answer: 2
    explanation: "Запись в закрытый канал вызывает panic. Закрывать канал должен только отправитель."

  - question: "Как проверить, закрыт ли канал при чтении?"
    options:
      - "ch.IsClosed()"
      - "value, ok := <-ch; ok будет false"
      - "closed(ch)"
      - "ch == nil"
    answer: 1
    explanation: "При чтении из канала вторая переменная (ok) показывает, открыт ли канал: value, ok := <-ch. Если ok == false — канал закрыт."

  - question: "Что означает тип chan<- int?"
    options:
      - "Канал только для чтения"
      - "Канал только для записи"
      - "Буферизованный канал"
      - "Закрытый канал"
    answer: 1
    explanation: "chan<- int — канал только для отправки. <-chan int — только для приёма. Направленные каналы ограничивают использование в функциях."

  - question: "Кто обычно должен закрывать канал?"
    options:
      - "Получатель"
      - "Отправитель"
      - "Функция main"
      - "Сборщик мусора"
    answer: 1
    explanation: "Канал закрывает отправитель, так как он знает, когда данные заканчиваются. Получатель не должен закрывать канал."

  # 03-select
  - question: "Что делает select в Go?"
    options:
      - "Выбирает тип переменной"
      - "Ожидает на нескольких каналах одновременно"
      - "Создаёт несколько горутин"
      - "Синхронизирует мьютексы"
    answer: 1
    explanation: "select позволяет горутине ожидать операции на нескольких каналах и выполнить ту ветку, которая станет готова первой."

  - question: "Что произойдёт, если несколько case в select готовы одновременно?"
    options:
      - "Выполнится первый по порядку"
      - "Выполнится последний"
      - "Выберется случайный"
      - "Ошибка компиляции"
    answer: 2
    explanation: "Если одновременно готовы несколько case, select выбирает один из них случайным образом."

  - question: "Для чего используется default в select?"
    options:
      - "Для обработки ошибок"
      - "Для неблокирующей операции — выполняется, если ни один канал не готов"
      - "Для закрытия каналов"
      - "Для инициализации"
    answer: 1
    explanation: "default делает select неблокирующим: если ни один канал не готов, выполняется default."

  - question: "Какой пакет рекомендуется использовать вместо done-каналов для отмены операций?"
    options:
      - "sync"
      - "context"
      - "signal"
      - "cancel"
    answer: 1
    explanation: "context.Context — рекомендуемый способ управления отменой, таймаутами и дедлайнами в горутинах."

  - question: "Что делает time.After(d) в контексте select?"
    options:
      - "Останавливает программу на d"
      - "Возвращает канал, который получит значение через d длительность"
      - "Устанавливает глобальный таймаут"
      - "Создаёт таймер с callback"
    answer: 1
    explanation: "time.After(d) возвращает <-chan Time, который получит значение через указанную duration. Используется для таймаутов в select."

  # 04-sync
  - question: "Как обнаружить гонку данных (data race) в Go?"
    options:
      - "go test -v"
      - "go run -race main.go"
      - "go vet main.go"
      - "go lint main.go"
    answer: 1
    explanation: "Флаг -race включает детектор гонок данных, встроенный в Go: go run -race, go test -race, go build -race."

  - question: "Чем RWMutex отличается от Mutex?"
    options:
      - "RWMutex быстрее во всех случаях"
      - "RWMutex позволяет множественные одновременные чтения"
      - "RWMutex работает только с картами"
      - "RWMutex не требует разблокировки"
    answer: 1
    explanation: "RWMutex позволяет нескольким горутинам читать одновременно (RLock), но запись (Lock) — эксклюзивна."

  - question: "Что гарантирует sync.Once?"
    options:
      - "Функция вызовется в каждой горутине"
      - "Функция выполнится ровно один раз, независимо от числа вызовов"
      - "Функция вызовется с задержкой"
      - "Функция вызовется атомарно"
    answer: 1
    explanation: "sync.Once.Do(f) гарантирует, что f будет выполнена ровно один раз, даже если Do вызывается из множества горутин."

  - question: "Когда лучше использовать sync.Map вместо map + RWMutex?"
    options:
      - "Всегда"
      - "Когда ключи стабильны (мало записей, много чтений) и горутины работают с разными ключами"
      - "Когда карта маленькая"
      - "Когда нужна сортировка ключей"
    answer: 1
    explanation: "sync.Map эффективна, когда ключи стабильны и разные горутины работают с разными ключами. В остальных случаях map + RWMutex эффективнее."

  - question: "Какой пакет предоставляет атомарные операции для простых счётчиков?"
    options:
      - "sync"
      - "sync/atomic"
      - "runtime"
      - "unsafe"
    answer: 2
    explanation: "Пакет sync/atomic предоставляет атомарные операции (AddInt64, LoadInt64 и т.д.) для простых счётчиков без мьютексов."
