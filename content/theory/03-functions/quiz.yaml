questions:
  # 01-functions
  - question: "Сколько значений может возвращать функция в Go?"
    options:
      - "Только одно"
      - "Не более двух"
      - "Любое количество"
      - "Максимум три"
    answer: 2
    explanation: "Функции в Go могут возвращать любое количество значений. Чаще всего используются два: результат и ошибка."

  - question: "Что означает синтаксис nums ...int в параметрах функции?"
    options:
      - "Указатель на int"
      - "Слайс int фиксированной длины"
      - "Вариативный параметр — функция принимает произвольное число int"
      - "Массив int"
    answer: 2
    explanation: "Вариативный параметр (variadic) позволяет передать произвольное количество аргументов. Внутри функции nums имеет тип []int."

  - question: "В каком порядке выполняются множественные defer?"
    options:
      - "В порядке объявления (FIFO)"
      - "В обратном порядке (LIFO — стек)"
      - "В случайном порядке"
      - "Параллельно"
    answer: 1
    explanation: "Множественные defer выполняются в порядке LIFO (стек): последний объявленный defer выполнится первым."

  - question: "Что такое замыкание (closure) в Go?"
    options:
      - "Функция, объявленная на уровне пакета"
      - "Анонимная функция, которая захватывает переменные из окружающего контекста"
      - "Метод структуры"
      - "Функция с именованными возвращаемыми значениями"
    answer: 1
    explanation: "Замыкание — анонимная функция, которая захватывает и «помнит» переменные из окружающей области видимости."

  - question: "Когда вызывается функция init()?"
    options:
      - "Вручную из main()"
      - "Автоматически при загрузке пакета, до main()"
      - "При первом вызове функции из пакета"
      - "При импорте с помощью ключевого слова init"
    answer: 1
    explanation: "init() вызывается автоматически при загрузке пакета, до выполнения main(). Можно иметь несколько init() в одном пакете."

  - question: "Как передать слайс в вариативную функцию sum(nums ...int)?"
    options:
      - "sum(slice)"
      - "sum(slice...)"
      - "sum(*slice)"
      - "sum(&slice)"
    answer: 1
    explanation: "Для передачи слайса в вариативную функцию используется оператор ...: sum(slice...)."

  # 02-errors
  - question: "Какой интерфейс реализуют ошибки в Go?"
    options:
      - "Throwable"
      - "Exception"
      - "error"
      - "Error"
    answer: 2
    explanation: "В Go ошибки реализуют интерфейс error с единственным методом Error() string."

  - question: "Что делает спецификатор %w в fmt.Errorf?"
    options:
      - "Выводит ошибку в формате wide"
      - "Оборачивает (wrap) ошибку, сохраняя оригинал в цепочке"
      - "Записывает ошибку в лог"
      - "Преобразует ошибку в строку"
    answer: 1
    explanation: "%w оборачивает ошибку, позволяя позже извлечь оригинал через errors.Is() или errors.As()."

  - question: "Для чего используется errors.Is?"
    options:
      - "Для создания новой ошибки"
      - "Для проверки ошибки по значению (с разворачиванием цепочки)"
      - "Для преобразования ошибки в строку"
      - "Для логирования ошибки"
    answer: 1
    explanation: "errors.Is проверяет, совпадает ли ошибка (или одна из обёрток) с конкретным значением-образцом."

  - question: "Когда допустимо использовать panic?"
    options:
      - "Для любой обработки ошибок"
      - "Вместо возврата error"
      - "Только для невосстановимых ситуаций (нарушение инвариантов)"
      - "Для валидации пользовательского ввода"
    answer: 2
    explanation: "panic используется только для действительно невосстановимых ситуаций. Для обычных ошибок возвращайте error."

  - question: "Как перехватить panic в Go?"
    options:
      - "try/catch"
      - "defer + recover()"
      - "except"
      - "handle()"
    answer: 1
    explanation: "recover() перехватывает panic, но работает только внутри отложенной функции (defer)."

  # 03-methods
  - question: "Чем метод отличается от функции в Go?"
    options:
      - "Метод может быть рекурсивным"
      - "Метод привязан к типу через ресивер (receiver)"
      - "Метод не может возвращать значения"
      - "Метод всегда публичный"
    answer: 1
    explanation: "Метод — функция с ресивером: func (r Type) Name(). Ресивер привязывает метод к конкретному типу."

  - question: "Когда использовать ресивер-указатель (*Type)?"
    options:
      - "Когда метод не изменяет структуру"
      - "Всегда"
      - "Когда метод изменяет структуру или она большая"
      - "Только для методов с возвращаемыми значениями"
    answer: 2
    explanation: "Ресивер-указатель используется, если метод изменяет ресивер, структура большая (избегаем копирования) или для единообразия."

  - question: "Что произойдёт при вызове метода с ресивером по значению?"
    options:
      - "Метод получит оригинальный объект"
      - "Метод получит копию объекта"
      - "Ошибка компиляции"
      - "Метод получит nil"
    answer: 1
    explanation: "Ресивер по значению передаёт копию. Изменения внутри метода не влияют на оригинал."

  # 04-interfaces
  - question: "Как тип реализует интерфейс в Go?"
    options:
      - "Через ключевое слово implements"
      - "Через наследование"
      - "Неявно — просто имея все необходимые методы"
      - "Через аннотации"
    answer: 2
    explanation: "В Go реализация интерфейсов неявная. Тип автоматически реализует интерфейс, если имеет все его методы."

  - question: "Что такое пустой интерфейс (interface{} или any)?"
    options:
      - "Интерфейс без реализации"
      - "Интерфейс, который принимает значения любого типа"
      - "Ошибочный интерфейс"
      - "Интерфейс только для примитивных типов"
    answer: 1
    explanation: "Пустой интерфейс не содержит методов, поэтому любой тип его реализует. Используется для обобщённых значений."

  - question: "Что делает type switch?"
    options:
      - "Переключает тип переменной"
      - "Проверяет конкретный тип значения интерфейса и выполняет соответствующую ветку"
      - "Создаёт новый тип"
      - "Конвертирует один тип в другой"
    answer: 1
    explanation: "Type switch (switch v.(type)) позволяет определить конкретный тип значения интерфейса и выполнить соответствующий код."

  - question: "Какой интерфейс нужно реализовать для кастомного вывода через fmt.Println?"
    options:
      - "io.Writer"
      - "fmt.Formatter"
      - "fmt.Stringer"
      - "io.Reader"
    answer: 2
    explanation: "Интерфейс fmt.Stringer требует метод String() string. Если тип его реализует, fmt.Println использует его для вывода."

  - question: "Что произойдёт при небезопасном type assertion (s.(Dog)), если тип не совпадает?"
    options:
      - "Вернётся нулевое значение"
      - "Вернётся nil"
      - "Паника (panic)"
      - "Ошибка компиляции"
    answer: 2
    explanation: "Небезопасный type assertion без ok вызывает panic, если тип не совпадает. Используйте безопасную форму: dog, ok := s.(Dog)."
